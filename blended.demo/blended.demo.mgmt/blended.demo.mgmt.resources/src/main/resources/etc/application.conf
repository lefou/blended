akka { #akka

  loggers = [ "akka.event.slf4j.Slf4jLogger" ]
  loglevel = info

  log-config-on-start = off

  actor { #akka.actor
    debug {
      receive = on
      lifecycle = on
    }
  } #actor

  http { #akka.http

    # TODO: work-around
    version = "10.0.11"

    server { #akka.http.server

      server-header = blended-akka-http

      preview { #akka.http.server.preview
        enable-http2 = off
      }

      idle-timeout = 60s
      request-timeout = 20s
      bind-timeout = 1s
      // FIXME: ports
      default-http-port = 80
      default-https-port = 443
      linger-timeout = 1min
      max-connections = 1024
      pipelining-limit = 16
      remote-address-header = off
      raw-request-uri-header = off
      transparent-head-requests = on
      verbose-error-messages = off
      response-header-size-hint = 512
      backlog = 100
      default-host-header = ""

      socket-options { #akka.http.server.socket-options
        so-receive-buffer-size = undefined
        so-send-buffer-size = undefined
        so-reuse-address = undefined
        so-traffic-class = undefined
        tcp-keep-alive = undefined
        tcp-oob-inline = undefined
        tcp-no-delay = undefined
      } #socket-options

      log-unencrypted-network-bytes = off

      http2 { #akka.http.server.http2
        request-entity-chunk-size = 65536 b
        incoming-connection-level-buffer-size = 10 MB
        incoming-stream-level-buffer-size = 512kB
      } #http2

      parsing {  #akka.http.server.parsing
        max-uri-length             = 2k
        max-method-length          = 16
        max-response-reason-length = 64
        max-header-name-length     = 64
        max-header-value-length    = 8k
        max-header-count           = 64
        max-chunk-ext-length       = 256
        max-chunk-size             = 1m
        max-content-length = 8m
        uri-parsing-mode = strict
        cookie-parsing-mode = rfc6265
        illegal-header-warnings = on
        modeled-header-parsing = on
        error-logging-verbosity = full
        illegal-response-header-value-processing-mode = error

        header-cache {  #akka.http.server.parsing.header-cache
          default = 12
          Content-MD5 = 0
          Date = 0
          If-Match = 0
          If-Modified-Since = 0
          If-None-Match = 0
          If-Range = 0
          If-Unmodified-Since = 0
          User-Agent = 32
        } #header-cache

        tls-session-info-header = off

      } #akka.http.server.parsing

    } #akka.http.server

    client {  #akka.http.client
      user-agent-header = blended-akka-http
      connecting-timeout = 10s
      idle-timeout = 60s
      request-header-size-hint = 512

      socket-options { #akka.http.client.socket-options
        so-receive-buffer-size = undefined
        so-send-buffer-size = undefined
        so-reuse-address = undefined
        so-traffic-class = undefined
        tcp-keep-alive = undefined
        tcp-oob-inline = undefined
        tcp-no-delay = undefined
      } #akka.http.client.socket-options

      parsing {
        # no overrides by default, see `akka.http.parsing` for default values
      }
      
      log-unencrypted-network-bytes = off

    } #akka.http.client

    host-connection-pool { #akka.http.host-connection-pool
      max-connections = 4
      min-connections = 0
      max-retries = 5
      max-open-requests = 32
      pipelining-limit = 1
      idle-timeout = 30 s
      pool-implementation = legacy
      response-entity-subscription-timeout = 1.second
      client = { #akka.http.host-connection-pool.client
        user-agent-header = blended-akka-http
        connecting-timeout = 10s
        idle-timeout = 60 s
        request-header-size-hint = 512
        proxy { #akka.http.host-connection-pool.client.proxy
          http = default
          https = default
        } #proxy

        socket-options { #akka.http.host-connection-pool.client.socket-options
          so-receive-buffer-size = undefined
          so-send-buffer-size = undefined
          so-reuse-address = undefined
          so-traffic-class = undefined
          tcp-keep-alive = undefined
          tcp-oob-inline = undefined
          tcp-no-delay = undefined
        } #akka.http.host-connection-pool.client.socket-options

        parsing { #akka.http.host-connection-pool.client.parsing
        }
      } #akka.http.host-connection-pool.client

    } #akka.http.host-connection-pool

    routing { #akka.http.routing
      verbose-error-messages = off
      file-get-conditional = on
      render-vanity-footer = yes
      range-coalescing-threshold = 80
      range-count-limit = 16
      decode-max-bytes-per-chunk = 1m
      file-io-dispatcher = ${akka.stream.blocking-io-dispatcher}
    } #akka.http.routing


    parsing { #akka.http.parsing
      max-uri-length             = 2k
      max-method-length          = 16
      max-response-reason-length = 64
      max-header-name-length     = 64
      max-header-value-length    = 8k
      max-header-count           = 64
      max-chunk-ext-length       = 256
      max-chunk-size             = 1m
      max-content-length = 8m
      uri-parsing-mode = strict
      cookie-parsing-mode = rfc6265
      illegal-header-warnings = on
      modeled-header-parsing = on
      error-logging-verbosity = full
      illegal-response-header-value-processing-mode = error

      header-cache { #akka.http.parsing.header-cache
        default = 12
        Content-MD5 = 0
        Date = 0
        If-Match = 0
        If-Modified-Since = 0
        If-None-Match = 0
        If-Range = 0
        If-Unmodified-Since = 0
        User-Agent = 32
      } #akka.http.parsing.header-cache

      tls-session-info-header = off
    } #akka.http.parsing

  } #akka.http

  stream { #akka.stream

    materializer { #akka.stream.materializer
      initial-input-buffer-size = 4
      max-input-buffer-size = 16
      dispatcher = ""
      subscription-timeout {
        mode = cancel
        timeout = 5s
      }
      debug-logging = off
      output-burst-limit = 1000
      auto-fusing = on
      max-fixed-buffer-size = 1000000000
      sync-processing-limit = 1000
      debug {
        fuzzing-mode = off
      }
      io.tcp {
        write-buffer-size = 16 KiB
      }
    } #akka.stream.materializer

    blocking-io-dispatcher = "akka.stream.default-blocking-io-dispatcher"

    default-blocking-io-dispatcher { #akka.stream.default-blocking-io-dispatcher
      type = "Dispatcher"
      executor = "thread-pool-executor"
      throughput = 1
      thread-pool-executor {
        fixed-pool-size = 16
      }
    } #akka.stream.default-blocking-io-dispatcher
  } #akka.stream


  ssl-config { #akka.ssl-config
    protocol = "TLSv1.2"
  } #akka.ssl-config

} #akka

# ssl configuration (used in akka)
ssl-config {
  logger = "com.typesafe.sslconfig.akka.util.AkkaLoggerBridge"

  # Whether we should use the default JVM SSL configuration or not
  # When false additional configuration will be applied on the context (as configured in ssl-config).
  default = false

  # The ssl protocol to use
  protocol = "TLSv1.2"

  # Whether revocation lists should be checked, if null, defaults to platform default setting.
  checkRevocation = null

  # A sequence of URLs for obtaining revocation lists
  revocationLists = []

  # The enabled cipher suites. If empty, uses the platform default.
  enabledCipherSuites = []

  # The enabled protocols. If empty, uses the platform default.
  enabledProtocols = ["TLSv1.2", "TLSv1.1", "TLSv1"]

  # The disabled signature algorithms
  disabledSignatureAlgorithms = ["MD2", "MD4", "MD5"]

  # The disabled key algorithms
  disabledKeyAlgorithms = ["RSA keySize < 2048", "DSA keySize < 2048", "EC keySize < 224"]

  # The debug configuration
  debug = []

  # The hostname verifier class.
  # If non null, should be the fully qualify classname of a class that imlpements HostnameVerifier,
  # otherwise the default will be used
  hostnameVerifierClass = null

  sslParameters {
    # translates to a setNeedClientAuth / setWantClientAuth calls
    # "default" – leaves the (which for JDK8 means wantClientAuth and needClientAuth are set to false.)
    # "none"    – `setNeedClientAuth(false)`
    # "want"    – `setWantClientAuth(true)`
    # "need"    – `setNeedClientAuth(true)`
    clientAuth = "default"

    # protocols (names)
    protocols = []
  }

  # Configuration for the key manager
  keyManager {
    # The key manager algorithm. If empty, uses the platform default.
    algorithm = null

    # The key stores
    stores = [
    ]
    # The key stores should look like this
    prototype.stores {
      # The store type. If null, defaults to the platform default store type, ie JKS.
      type = null

      # The path to the keystore file. Either this must be non null, or data must be non null.
      path = null

      # The data for the keystore. Either this must be non null, or path must be non null.
      data = null

      # The password for loading the keystore. If null, uses no password.
      password = null
    }
  }

  trustManager {
    # The trust manager algorithm. If empty, uses the platform default.
    algorithm = null

    # The trust stores
    stores = [
    ]
    # The key stores should look like this
    prototype.stores {
      # The store type. If null, defaults to the platform default store type, ie JKS.
      type = null

      # The path to the keystore file. Either this must be non null, or data must be non null.
      path = null

      # The data for the keystore. Either this must be non null, or path must be non null.
      data = null
    }

  }

  # The loose ssl options.  These allow configuring ssl to be more loose about what it accepts,
  # at the cost of introducing potential security issues.
  loose {

    # Whether weak protocols should be allowed
    allowWeakProtocols = false

    # Whether weak ciphers should be allowed
    allowWeakCiphers = false

    # If non null, overrides the platform default for whether legacy hello messsages should be allowed.
    allowLegacyHelloMessages = null

    # If non null, overrides the platform defalut for whether unsafe renegotiation should be allowed.
    allowUnsafeRenegotiation = null

    # Whether hostname verification should be disabled
    disableHostnameVerification = false

    # Whether the SNI (Server Name Indication) TLS extension should be disabled
    # This setting MAY be respected by client libraries.
    #
    # https://tools.ietf.org/html/rfc3546#sectiom-3.1
    disableSNI = false

    # Whether any certificate should be accepted or not
    acceptAnyCertificate = false
  }

  # Debug configuration
  debug {
    # Turn on all debugging
    all = false
    # Turn on ssl debugging
    ssl = false
    # Turn certpath debugging on
    certpath = false
    # Turn ocsp debugging on
    ocsp = false
    # Enable per-record tracing
    record = false
    # hex dump of record plaintext, requires record to be true
    plaintext = false
    # print raw SSL/TLS packets, requires record to be true
    packet = false
    # Print each handshake message
    handshake = false
    # Print hex dump of each handshake message, requires handshake to be true
    data = false
    # Enable verbose handshake message printing, requires handshake to be true
    verbose = false
    # Print key generation data
    keygen = false
    # Print session activity
    session = false
    # Print default SSL initialization
    defaultctx = false
    # Print SSLContext tracing
    sslctx = false
    # Print session cache tracing
    sessioncache = false
    # Print key manager tracing
    keymanager = false
    # Print trust manager tracing
    trustmanager = false
    # Turn pluggability debugging on
    pluggability = false
  }
}


blended.activemq.defaultbroker {
  brokerName = blended
  file = "broker.amq"
  provider = activemq
}

blended.akka.http {
  host = "0.0.0.0"
  port = 9991
  ssl {
    host = "0.0.0.0"
    port = 9992
  }
}

blended.samples.jms {
  producerInterval = 1000
  destination = "topic:SampleTopic"
  consumeSelector = "SampleCounter LIKE '%0'"
}

blended.security.cert {
  alias = "default"
  keyStore = ${blended.container.home}/etc/keystore
  storePass = "blended"
  keyPass = "mysecret"
  overwriteForFailure = false

  selfsigned {
    subject="CN=blended,O=blended,C=Germany"
    validDays="10"
    keyStrength=2048
    signatureAlgorithm="SHA256withRSA"
  }
}

blended.updater.remote {
  repository {
    runtimeConfigsPath = ${BLENDED_HOME}/repositories/rcs
    overlayConfigsPath = ${BLENDED_HOME}/repositories/ocs
  }
}

blended.mgmt.repo {
  repoId = "artifacts",
  baseDir = ${BLENDED_HOME}/repositories/artifacts
}

blended.persistence.orient {
  dbPath = ${BLENDED_HOME}/orient/blended.persistence.orient
  dbUserName = admin
  dbPassword = admin
}

spray {
  servlet {
    boot-class = "NAME_DOES_NOT_MATTER"
    request-timeout = 30 s
    timeout-timeout = 500 ms
    timeout-handler = ""
    root-path = AUTO
    remote-address-header = off
    verbose-error-messages = off
    max-content-length = 5 m
    servlet-request-access = off
    illegal-header-warnings = on
    uri-parsing-mode = relaxed
  }

  routing {
    verbose-error-messages = off
    file-chunking-threshold-size = 128k
    file-chunking-chunk-size = 128k
    file-get-conditional = on
    render-vanity-footer = yes
    users {
      # bob = secret
    }
    range-coalescing-threshold = 80
    range-count-limit = 16
  }

  can {

    server {
      server-header = spray-can/${spray.version}
      ssl-encryption = off
      pipelining-limit = 1
      idle-timeout = 60 s
      request-timeout = 20 s
      timeout-timeout = 2 s
      chunkhandler-registration-timeout = 500 ms
      timeout-handler = ""
      reaping-cycle = 250 ms
      stats-support = on
      remote-address-header = off
      raw-request-uri-header = off
      transparent-head-requests = on
      chunkless-streaming = off
      verbose-error-messages = off
      request-chunk-aggregation-limit = 1m
      response-header-size-hint = 512
      max-encryption-chunk-size = 1m
      bind-timeout = 1s
      unbind-timeout = 1s
      registration-timeout = 1s
      parsing-error-abort-timeout = 2s
      default-host-header = ""
      automatic-back-pressure-handling = on
      back-pressure {
          noack-rate = 10
          reading-low-watermark = infinite
      }
      ssl-tracing = off
      parsing = ${spray.can.parsing}
    }

    client {
      user-agent-header = spray-can/${spray.version}
      idle-timeout = 60 s
      request-timeout = 20 s
      reaping-cycle = 250 ms
      response-chunk-aggregation-limit = 1m
      chunkless-streaming = off
      request-header-size-hint = 512
      max-encryption-chunk-size = 1m
      connecting-timeout = 10s
      proxy {
        http = default
        https = default
      }

      ssl-tracing = off
      parsing = ${spray.can.parsing}
    }

    host-connector {
      max-connections = 4
      max-retries = 5
      max-redirects = 0
      pipelining = off
      idle-timeout = 30 s
      client = ${spray.can.client}
    }

    parsing {
      max-uri-length             = 2k
      max-response-reason-length = 64
      max-header-name-length     = 64
      max-header-value-length    = 8k
      max-header-count           = 64
      max-content-length         = 8m
      max-chunk-ext-length       = 256
      max-chunk-size             = 1m
      uri-parsing-mode = strict
      illegal-header-warnings = on

      header-cache {
        default = 12
        Content-MD5 = 0
        Date = 0
        If-Match = 0
        If-Modified-Since = 0
        If-None-Match = 0
        If-Range = 0
        If-Unmodified-Since = 0
        User-Agent = 32
      }

      incoming-auto-chunking-threshold-size = infinite
      ssl-session-info-header = off
    }

    manager-dispatcher = "akka.actor.default-dispatcher"
    settings-group-dispatcher = "akka.actor.default-dispatcher"
    host-connector-dispatcher = "akka.actor.default-dispatcher"
    listener-dispatcher = "akka.actor.default-dispatcher"
    connection-dispatcher = "akka.actor.default-dispatcher"
  }
}
